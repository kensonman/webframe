# The file is used as a template for GitLab-CI building template.
# It defined the basic step to getting start, e.g.: Versioning
stages:
   - pre
   - test
   - build
   - release
   - post

# Default Variables here
variables:
   GIT_STRATEGY: "fetch"
   GIT_SUBMODULE_STRATEGY: "recursive"

# Default Job Specification
default:
   image: "python:3-alpine"

.default-rules:
   rules:
      - if: $CI_COMMIT_TAG =~ /^release(s)?\//
        when: never

.on-versioning-branch:
   rules:
      - !reference [.default-rules, rules]

      # If the tag name is matched with regex: 1.2.3-rc.4+build.5
      - if: $CI_COMMIT_TAG =~ /^([0-9]+\.){2}([0-9]+){1}(\-[a-zA-Z\.]*[0-9]+)?(\+[a-zA-Z\.]*[0-9]+)?/

      # If protected branch/tag only
      - if: '$CI_COMMIT_REF_PROTECTED == "true"'

# Prepare the versioning
prepare:
   stage: pre
   rules:
      - !reference [.default-rules, rules]
      - when: always
   image: "kensonman/versioning:2.0.0"
   script:
      - >
         echo "Preparing the CI/CD environment: `pwd`..." && \
         echo "   > CI_COMMIT_BRANCH: ${CI_COMMIT_BRANCH}" && \
         echo "   > CI_COMMIT_TAG: ${CI_COMMIT_TAG}" && \
         echo "   > CI_COMMIT_MESSAGE: ${CI_COMMIT_MESSAGE}" && \
         echo "   > CI_COMMIT_REF_PROTECTED: ${CI_COMMIT_REF_PROTECTED}" && \
         echo "   > Getting the next version..." && \
         export VERSION=`versioning.py getVersion` && \
         echo "   > Next version: ${VERSION}" && \
         export DOCKERIZED_VERSION=`versioning.py --option ${VERSION} toDockerized` && \
         echo "   > Dockerized next version: ${DOCKERIZED_VERSION}" && \
         echo "   > Exporting..." && \
         echo "VERSION=${VERSION}" > VERSION.env && \
         echo "DOCKERIZED_VERSION=${DOCKERIZED_VERSION}" >> VERSION.env && \
         echo "${VERSION}" > VERSION && \
         echo "VERSION.env:" && \
         cat  VERSION.env
   artifacts:
      reports:
         # Put the version into env for sharing the variable between job
         dotenv: VERSION.env
      paths:
         # Put the VERSION as an artifact for futer development
         - VERSION

# Teting the binary/output which builded by "building" job.
testing:
   stage: test
   rules:
      - if: $CI_COMMIT_TITLE =~ /CI:NoTesting/
        when: never
      - !reference [.default-rules, rules]
      - when: always
   variables:
      CI_BUILDS_DIR: /src/webframe
      DBMS: django.db.backends.sqlite3
      DBNAME: /tmp/testing.db
   before_script:
      - >
         echo "Installing the dependencies..." && \
         pip install --upgrade pip && \
         apk add --upgrade --no-cache bash gettext build-base jpeg-dev nginx python3-dev openldap-dev libressl-dev musl-dev libffi-dev postgresql-dev gcc python3-dev musl-dev jpeg-dev zlib-dev vim openssl-dev py3-lxml py3-pyldap && \
         pip install . && \
         pip install pycryptodome pytest pytest-django
      - >
         django-admin startproject conf && \
         mv conf tempproj && \
         mv tempproj/* . && \
         rmdir tempproj && \
         ln -s ../webframe conf/webframe && \
         echo 'INSTALLED_APPS+=["django_summernote"]' >> conf/settings.py && \
         echo 'INSTALLED_APPS+=["webframe"]' >> conf/settings.py && \
         echo 'INSTALLED_APPS+=["rest_framework.authtoken"]' >> conf/settings.py && \
         echo 'from django.urls import include' >> conf/urls.py && \
         echo 'urlpatterns += [path("webframe/", include("webframe.urls")),]' >>conf/urls.py
   script:
      - >
         echo "Testing..." && \
         pytest --junitxml=test-results.xml
   artifacts:
      when: always
      paths:
      - test-results.xml
      reports:
         junit: test-results.xml

# Building the binary/output according to the string. It may be the docker image
building:
   stage: build
   dependencies:
      - prepare
      - testing
   rules:
      - if: $CI_COMMIT_TITLE =~ /CI:NoBuilding/
        when: never
      - !reference [.on-versioning-branch, rules]
   variables:
      VERSION: value-from-prepare
   before_script:
      - > 
         echo "B4 script on `pwd`..."
         && ./dependencies.sh
   script:
      - >
         echo "Building on `pwd`..." && \
         django-admin startproject conf && \
         mv conf tempproj && \
         mv tempproj/* . && \
         rmdir tempproj && \
         ln -s ../webframe conf/webframe && \
         echo "INSTALLED_APPS += ['webframe', 'rest_framework', 'rest_framework.authtoken', 'django_summernote']" >> conf/settings.py && \
         echo 'from django.urls import include' >> conf/urls.py && \
         echo 'urlpatterns += [path("webframe/", include("webframe.urls")),]' >>conf/urls.py && \
         cd webframe && \
         ../manage.py compilemessages && \
         cd .. && \
         echo "STATIC_ROOT=`pwd`/webframe/static" >> conf/settings.py && \
         ./manage.py collectstatic && \
         sed -i "s/version=.*/version='${VERSION}',/g" setup.py && \
         python setup.py build && \
         python setup.py bdist && \
         echo "DIST_URL=\"https://repos.kenson.idv.hk/kenson/webframe/-/jobs/artifacts/${CI_JOB_ID}/browse\"" > URL.env
   artifacts:
      reports:
         # Put the version into env for sharing the variable between job
         dotenv: URL.env
      paths:
         - dist/


# Releasing the binary/output. Usually push the docker image into the registry
releasing:
   image: registry.gitlab.com/gitlab-org/release-cli:latest
   stage: release
   needs:
      - job: building
        artifacts: true
   dependencies:
      - prepare
      - building
   rules:
      - if: $CI_COMMIT_TITLE =~ /CI:Releasing/
        when: never
      - !reference [.on-versioning-branch, rules]
   variables:
      VERSION: value-from-prepare 
      DOCKERIZED_VERSION: value-from-prepare
      #Don't pull the source code
      GIT_STRATEGY: none
      DIST_URL: value-from-building
   script: 
      - > 
         echo "Creating release: $VERSION..."
   release:
      name: "Release - $VERSION"
      description: "$CI_COMMIT_REF_NAME - $CI_COMMIT_MESSAGE"
      tag_name: "$VERSION"
      ref: '$CI_COMMIT_REF_NAME'
      assets:
         links:
            - name: Python Egg
              url: ${DIST_URL}

# Cleaning the CI/CD
clean:
   stage: post
   rules:
      - if: $CI_COMMIT_TITLE =~ /CI:Cleaning/
        when: never
      - !reference [.default-rules, rules]
      - when: always
   variables:
      #Don't pull the source code
      GIT_STRATEGY: none
   script:
      - >
         echo "Cleaning up..."
