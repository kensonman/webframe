# The file is used as a template for GitLab-CI building template.
# It defined the basic step to getting start, e.g.: Versioning
stages:
   - pre
   - test
   - build
   - release
   - post

# Default Variables here
variables:
   GIT_STRATEGY: "fetch"
   GIT_SUBMODULE_STRATEGY: "recursive"

# Default Job Specification
default:
   image: "python:3-alpine"

.default-rules:
   rules:
      - if: $CI_COMMIT_TAG =~ /^release(s)?\//
        when: never

.on-versioning-branch:
   rules:
      - !reference [.default-rules, rules]

      # If the tag name is matched with regex: 1.2.3-rc.4+build.5
      - if: $CI_COMMIT_TAG =~ /^([0-9]+\.){2}([0-9]+){1}(\-[a-zA-Z\.]*[0-9]+)?(\+[a-zA-Z\.]*[0-9]+)?/

      # If the commit-title is match with regex: 1.2.3-rc.4+build.5
      - if: $CI_COMMIT_TITLE =~ /^([0-9]+\.){2}([0-9]+){1}(\-[a-zA-Z\.]*[0-9]+)?(\+[a-zA-Z\.]*[0-9]+)? -/

      # If the branch is match with regex, e.g.: 1.2.3-rc.4+build.x
      - if: $CI_COMMIT_BRANCH =~ /^([0-9]+\.){0,3}([0-9]+[\+\-]){0,2}x$/

# Prepare the versioning
prepare:
   stage: pre
   rules:
      - !reference [.default-rules, rules]
      - when: always
   image: "kensonman/versioning:1.0.7-build.6"
   script:
      - >
         echo "Preparing the CI/CD environment: `pwd`..."
         && git config --global --add safe.directory `pwd`
         && echo "   > Detecting the versioning pattern: `version.py getVersionPattern`"
         && echo "   > Getting the last version..."
         && echo "     > Last version artifact url: `version.py getLastVersionArtifactUrl`"
         && export VERSION=`version.py getLastVersion`
         && echo "     > Last version: ${VERSION}"
         && export VERSION=`version.py getNextVersion`
         && echo "   > Next version: ${VERSION}"
         && echo "   > Exporting..."
         && echo "VERSION=${VERSION}" > VERSION.env
         && echo "${VERSION}" > VERSION
   artifacts:
      reports:
         # Put the version into env for sharing the variable between job
         dotenv: VERSION.env
      paths:
         # Put the VERSION as an artifact for futer development
         - VERSION

# Teting the binary/output which builded by "building" job.
testing:
   stage: test
   rules:
      - if: $CI_COMMIT_TITLE =~ /CI:NoTesting/
        when: never
      - !reference [.default-rules, rules]
      - when: always
   variables:
      CI_BUILDS_DIR: /src/webframe
      DBMS: django.db.backends.sqlite3
      DBNAME: /tmp/testing.db
   before_script:
      - >
         echo "Installing the dependencies..." && \
         pip install --upgrade pip && \
         apk add --upgrade --no-cache bash gettext build-base jpeg-dev nginx python3-dev openldap-dev libressl-dev musl-dev libffi-dev postgresql-dev gcc python3-dev musl-dev jpeg-dev zlib-dev vim openssl-dev py3-lxml py3-pyldap && \
         pip install . && \
         pip install pycryptodome pytest pytest-django
      - >
         django-admin startproject conf && \
         mv conf tempproj && \
         mv tempproj/* . && \
         rmdir tempproj && \
         ln -s ../webframe conf/webframe && \
         echo 'INSTALLED_APPS+=["django_summernote"]' >> conf/settings.py && \
         echo 'INSTALLED_APPS+=["webframe"]' >> conf/settings.py && \
         echo 'INSTALLED_APPS+=["rest_framework.authtoken"]' >> conf/settings.py && \
         echo 'from django.urls import include' >> conf/urls.py && \
         echo 'urlpatterns += [path("webframe/", include("webframe.urls")),]' >>conf/urls.py
   script:
      - >
         echo "Testing..." && \
         pytest --junitxml=test-results.xml
   artifacts:
      when: always
      paths:
      - test-results.xml
      reports:
         junit: test-results.xml

# Building the binary/output according to the string. It may be the docker image
building:
   stage: build
   dependencies:
      - prepare
      - testing
   rules:
      - if: $CI_COMMIT_TITLE =~ /CI:NoBuilding/
        when: never
      - !reference [.on-versioning-branch, rules]
   variables:
      VERSION: value-from-prepare
   before_script:
      - > 
         echo "B4 script on `pwd`..."
         && ./dependencies.sh
   script:
      - >
         echo "Building on `pwd`..."
         && cd ..
         && django-admin startproject testproj
         && mv testproj proj
         && mv proj/* .
         && rmdir proj
         && echo "INSTALLED_APPS += ['webframe', 'rest_framework', 'rest_framework.authtoken', 'django_summernote']" >> testproj/settings.py
         && echo "from django.urls import path, re_path, include" >> testproj/urls.py
         && echo "urlpatterns += [path('webframe/', include('webframe.urls', namespace='webframe')),]" >> testproj/urls.py
         && echo 
         && cd webframe
         && ../manage.py compilemessages
         && cd ..
         && echo "STATIC_ROOT=`pwd`/webframe/static" >> testproj/settings.py
         && ./manage.py collectstatic
   artifacts:
      paths:
         - locale/
         - static/


# Releasing the binary/output. Usually push the docker image into the registry
releasing:
   image: registry.gitlab.com/gitlab-org/release-cli:latest
   stage: release
   dependencies:
      - prepare
      - building
   rules:
      - if: $CI_COMMIT_TITLE =~ /CI:Releasing/
        when: never
      - !reference [.on-versioning-branch, rules]
   variables:
      VERSION: value-from-prepare 
      DOCKERIZED_VERSION: value-from-prepare
      #Don't pull the source code
      GIT_STRATEGY: none
   script: 
      - > 
         echo "Creating release: $VERSION..."
   release:
      name: "Release - $VERSION"
      description: "$CI_COMMIT_REF_NAME - $CI_COMMIT_MESSAGE"
      tag_name: "$VERSION"
      ref: '$CI_COMMIT_REF_NAME'

# Cleaning the CI/CD
clean:
   stage: post
   rules:
      - if: $CI_COMMIT_TITLE =~ /CI:Cleaning/
        when: never
      - !reference [.default-rules, rules]
      - when: always
   variables:
      #Don't pull the source code
      GIT_STRATEGY: none
   script:
      - >
         echo "Cleaning up..."
